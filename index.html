<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Amazon Subscribe & Save</title>
  <link rel="icon" href="https://www.amazon.com/favicon.ico">
  <link rel="apple-touch-icon" href="https://www.amazon.com/favicon.ico">

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f5f5f5; color: #333; padding: 20px; }
    .header-row { display: flex; align-items: center; gap: 8px; margin-bottom: 4px; }
    h1 { font-size: 1.5rem; }
    .sync-dot { width: 8px; height: 8px; border-radius: 50%; background: #999; transition: background 0.3s; flex-shrink: 0; }
    .sync-dot.connected { background: #4caf50; }
    .subtitle { color: #666; margin-bottom: 6px; font-size: 0.9rem; }
    .deadline { color: #d32f2f; font-weight: 600; margin-bottom: 16px; font-size: 0.9rem; }
    .controls { display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap; align-items: center; }
    .controls button { padding: 8px 14px; border: 1px solid #ccc; border-radius: 6px; background: #fff; cursor: pointer; font-size: 0.82rem; }
    .controls button:hover { background: #e8e8e8; }
    .controls button.primary { background: #ff9900; color: #fff; border-color: #e88a00; font-weight: 600; }
    .controls button.primary:hover { background: #e88a00; }
    .controls button.danger { background: #d32f2f; color: #fff; border-color: #b71c1c; font-weight: 600; }
    .controls button.danger:hover { background: #b71c1c; }
    .controls button.active { background: #146eb4; color: #fff; border-color: #0d5a9e; }
    .summary { background: #fff; border-radius: 8px; padding: 12px 16px; margin-bottom: 16px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); font-size: 0.9rem; }
    .summary span { font-weight: 600; }
    .item-list { list-style: none; }
    .group-divider { padding: 10px 16px 6px; font-size: 0.8rem; font-weight: 600; color: #555; text-transform: uppercase; letter-spacing: 0.5px; border-bottom: 2px solid #ddd; margin-top: 18px; margin-bottom: 6px; }
    .group-divider:first-child { margin-top: 0; }
    .item { background: #fff; border-radius: 8px; padding: 12px 16px; margin-bottom: 6px; display: flex; align-items: flex-start; gap: 12px; box-shadow: 0 1px 3px rgba(0,0,0,0.08); transition: opacity 0.2s; }
    .item.unchecked { opacity: 0.45; }
    .item input[type="checkbox"] { width: 20px; height: 20px; cursor: pointer; accent-color: #ff9900; flex-shrink: 0; margin-top: 2px; }
    .item-num { font-size: 0.8rem; color: #999; width: 24px; text-align: right; flex-shrink: 0; margin-top: 2px; }
    .item-details { flex: 1; min-width: 0; }
    .item-name { font-weight: 500; font-size: 0.95rem; }
    .item-meta { font-size: 0.8rem; color: #777; margin-top: 2px; display: flex; flex-wrap: wrap; gap: 4px; align-items: center; }
    .item-price { font-weight: 600; color: #111; white-space: nowrap; flex-shrink: 0; margin-top: 2px; }
    .unavailable { color: #d32f2f; font-style: italic; font-size: 0.8rem; }
    .vet-note { color: #e65100; font-style: italic; font-size: 0.8rem; }
    .search { padding: 8px 12px; border: 1px solid #ccc; border-radius: 6px; font-size: 0.9rem; width: 180px; }
    .toast { position: fixed; bottom: 24px; left: 50%; transform: translateX(-50%); background: #333; color: #fff; padding: 10px 24px; border-radius: 8px; font-size: 0.9rem; z-index: 999; opacity: 0; transition: opacity 0.3s; pointer-events: none; }
    .toast.show { opacity: 1; }

    /* Alternatives */
    .alt-toggle { font-size: 0.8rem; color: #146eb4; cursor: pointer; margin-top: 4px; display: inline-block; }
    .alt-toggle:hover { text-decoration: underline; }
    .alt-list { margin-top: 6px; padding: 8px 12px; background: #f9f9f9; border-radius: 6px; font-size: 0.82rem; display: none; }
    .alt-list.open { display: block; }
    .alt-item { display: flex; align-items: center; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid #eee; gap: 8px; }
    .alt-img { width: 40px; height: 40px; object-fit: contain; border-radius: 4px; flex-shrink: 0; background: #fff; }
    .item-img { width: 50px; height: 50px; object-fit: contain; border-radius: 4px; flex-shrink: 0; background: #fff; margin-right: 8px; }
    .alt-item:last-child { border-bottom: none; }
    .alt-info { flex: 1; }
    .alt-name { font-weight: 500; }
    .alt-meta { color: #777; font-size: 0.78rem; }
    .alt-savings { color: #1e7e34; font-weight: 600; font-size: 0.78rem; }
    .alt-savings.more-expensive { color: #d32f2f; }
    .alt-recommended { display: inline-block; background: #1e7e34; color: #fff; font-size: 0.68rem; font-weight: 600; padding: 1px 6px; border-radius: 3px; margin-left: 6px; }
    .alt-switch { padding: 3px 10px; border: 1px solid #146eb4; border-radius: 4px; background: #fff; color: #146eb4; cursor: pointer; font-size: 0.75rem; margin-left: 8px; white-space: nowrap; }
    .alt-switch:hover { background: #e8f0fe; }
    .alt-switch.selected { background: #146eb4; color: #fff; }
    .pref-alt { color: #146eb4; font-size: 0.78rem; margin-left: 6px; }

    /* Cancel */
    .cancel-btn { background: none; border: none; color: #d32f2f; font-size: 1.1rem; cursor: pointer; padding: 2px 6px; line-height: 1; opacity: 0.4; transition: opacity 0.2s; flex-shrink: 0; margin-top: 1px; }
    .cancel-btn:hover { opacity: 1; }
    .item.cancelled { opacity: 0.35; }
    .item.cancelled .item-name { text-decoration: line-through; color: #999; }
    .cancel-label { color: #d32f2f; font-size: 0.75rem; font-weight: 500; margin-left: 8px; }

    /* Badges */
    .price-badge { font-size: 0.72rem; color: #1e7e34; font-weight: 500; margin-left: 6px; }
    .last-checked { font-size: 0.7rem; color: #aaa; margin-left: 6px; }
    .history-badge { font-size: 0.7rem; color: #666; background: #f0f0f0; padding: 1px 6px; border-radius: 3px; cursor: help; }

    /* Urgency badges */
    .urgency-badge { font-size: 0.7rem; font-weight: 600; padding: 1px 8px; border-radius: 10px; white-space: nowrap; }
    .urgency-badge.due-soon { background: #ffebee; color: #c62828; }
    .urgency-badge.maybe { background: #fff8e1; color: #f57f17; }
    .urgency-badge.stock-ok { background: #e8f5e9; color: #2e7d32; }

    /* Predicted next date */
    .next-date { font-size: 0.72rem; color: #555; }

    /* Store badges */
    .store-badge { font-size: 0.68rem; font-weight: 600; padding: 1px 6px; border-radius: 3px; color: #fff; white-space: nowrap; }
    .store-badge.amazon { background: #ff9900; }
    .store-badge.target { background: #cc0000; }
    .store-badge.walmart { background: #0071dc; }
    .store-badge.costco { background: #e31837; }
    .store-badge.sams { background: #0060a9; }
    .best-value-row { background: #e8f5e9; padding: 6px 8px; border-radius: 4px; margin-top: 6px; font-size: 0.8rem; color: #1b5e20; font-weight: 500; }
    .recommendation { padding: 6px 10px; border-radius: 6px; font-size: 0.8rem; font-weight: 500; margin-top: 4px; display: flex; align-items: center; gap: 6px; }
    .recommendation.rec-keep { background: #e8f5e9; color: #1b5e20; border-left: 3px solid #4caf50; }
    .recommendation.rec-switch { background: #e3f2fd; color: #0d47a1; border-left: 3px solid #1976d2; }
    .recommendation.rec-competitor { background: #fff3e0; color: #e65100; border-left: 3px solid #ff9800; }
    .recommendation .rec-action { font-weight: 700; text-transform: uppercase; font-size: 0.7rem; padding: 1px 6px; border-radius: 3px; color: #fff; }
    .recommendation .rec-action.keep { background: #4caf50; }
    .recommendation .rec-action.switch { background: #1976d2; }
    .recommendation .rec-action.buy { background: #ff9800; }
    .recommendation .rec-detail { flex: 1; }
    .recommendation .rec-savings { font-weight: 700; }
    .recommendation a { color: inherit; }
    .alt-link { padding: 3px 10px; border: 1px solid #999; border-radius: 4px; background: #fff; color: #555; cursor: pointer; font-size: 0.75rem; margin-left: 8px; text-decoration: none; white-space: nowrap; }
    .alt-link:hover { background: #f5f5f5; }

    /* Coupon badges */
    .coupon-badge { display: inline-block; background: #1e7e34; color: #fff; font-size: 0.7rem; font-weight: 600; padding: 1px 6px; border-radius: 3px; }
    .effective-price { font-size: 0.72rem; color: #1e7e34; font-weight: 500; }

    /* Price trend */
    .trend-up { color: #d32f2f; }
    .trend-down { color: #1e7e34; }
    .trend-flat { color: #777; }
    .week52-low { font-size: 0.68rem; background: #e8f5e9; color: #1b5e20; padding: 1px 6px; border-radius: 3px; font-weight: 600; }

    /* Deletion section */
    .deletion-section { margin-top: 24px; }
    .deletion-header { font-size: 1.1rem; font-weight: 600; color: #d32f2f; margin-bottom: 8px; padding-bottom: 6px; border-bottom: 2px solid #d32f2f; }
    .deletion-card { background: #fff; border-radius: 8px; padding: 12px 16px; margin-bottom: 6px; box-shadow: 0 1px 3px rgba(0,0,0,0.08); border-left: 4px solid #d32f2f; }
    .deletion-card .dc-name { font-weight: 600; font-size: 0.95rem; }
    .deletion-card .dc-reason { color: #d32f2f; font-size: 0.82rem; margin-top: 4px; }
    .deletion-card .dc-stats { font-size: 0.8rem; color: #777; margin-top: 4px; }

    /* Dashboard */
    .dashboard { background: #fff; border-radius: 8px; padding: 16px; margin-bottom: 16px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
    .dashboard-header { display: flex; justify-content: space-between; align-items: center; cursor: pointer; }
    .dashboard-header h2 { font-size: 1.1rem; }
    .dashboard-toggle { font-size: 0.8rem; color: #146eb4; }
    .dashboard-body { display: none; margin-top: 12px; }
    .dashboard-body.open { display: block; }
    .dash-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 12px; }
    .dash-card { background: #f9f9f9; border-radius: 6px; padding: 12px; text-align: center; }
    .dash-card .dash-value { font-size: 1.5rem; font-weight: 700; color: #111; }
    .dash-card .dash-label { font-size: 0.78rem; color: #777; margin-top: 2px; }
    .dash-categories { margin-top: 12px; }
    .dash-categories h3 { font-size: 0.85rem; color: #555; margin-bottom: 6px; }
    .cat-row { display: flex; justify-content: space-between; padding: 3px 0; font-size: 0.82rem; border-bottom: 1px solid #f0f0f0; }

    /* Frequency recommendations */
    .freq-recs { margin-bottom: 16px; }
    .freq-recs h3 { font-size: 0.95rem; margin-bottom: 8px; color: #555; }
    .freq-rec-card { background: #fff; border-radius: 8px; padding: 10px 14px; margin-bottom: 6px; box-shadow: 0 1px 3px rgba(0,0,0,0.08); border-left: 4px solid #146eb4; font-size: 0.85rem; }
    .freq-rec-card .rec-title { font-weight: 600; }
    .freq-rec-card .rec-detail { color: #777; margin-top: 2px; }
    .freq-rec-card .rec-savings { color: #1e7e34; font-weight: 600; margin-top: 2px; }

    /* Alert cards */
    .alerts-section { margin-bottom: 16px; }
    .alert-card { background: #fff3e0; border-radius: 8px; padding: 10px 14px; margin-bottom: 6px; box-shadow: 0 1px 3px rgba(0,0,0,0.08); border-left: 4px solid #ff9800; font-size: 0.85rem; }
    .alert-card .alert-title { font-weight: 600; color: #e65100; }
    .alert-card .alert-detail { color: #777; margin-top: 2px; }

    /* Implement modal */
    .modal-overlay { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1000; justify-content: center; align-items: center; }
    .modal-overlay.open { display: flex; }
    .modal { background: #fff; border-radius: 12px; padding: 24px; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto; }
    .modal h2 { margin-bottom: 16px; font-size: 1.2rem; }
    .modal-actions { margin-top: 8px; }
    .modal-action { padding: 6px 0; font-size: 0.85rem; border-bottom: 1px solid #f0f0f0; }
    .modal-action:last-child { border-bottom: none; }
    .modal-action .action-type { font-weight: 600; text-transform: uppercase; font-size: 0.72rem; padding: 1px 6px; border-radius: 3px; color: #fff; margin-right: 6px; }
    .action-type.skip { background: #ff9800; }
    .action-type.switch { background: #146eb4; }
    .action-type.cancel { background: #d32f2f; }
    .modal-buttons { display: flex; gap: 8px; margin-top: 16px; justify-content: flex-end; }
    .modal-buttons button { padding: 8px 20px; border-radius: 6px; border: 1px solid #ccc; cursor: pointer; font-size: 0.9rem; }
    .modal-buttons .btn-confirm { background: #ff9900; color: #fff; border-color: #e88a00; font-weight: 600; }
    .modal-buttons .btn-cancel { background: #fff; }

    /* Progress bar */
    .progress-section { display: none; background: #fff; border-radius: 8px; padding: 12px 16px; margin-bottom: 16px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
    .progress-section.active { display: block; }
    .progress-bar-track { background: #e0e0e0; border-radius: 4px; height: 8px; margin-top: 8px; overflow: hidden; }
    .progress-bar-fill { background: #ff9900; height: 100%; border-radius: 4px; transition: width 0.3s; width: 0%; }
    .progress-label { font-size: 0.82rem; color: #555; }
    .progress-detail { font-size: 0.78rem; color: #999; margin-top: 4px; }

    /* Bulk buy suggestions */
    .bulk-suggestion { font-size: 0.72rem; color: #146eb4; margin-top: 2px; }
  </style>
</head>
<body>
  <div class="header-row">
    <h1><span style="display:inline-block;transform:rotate(180deg);margin-right:2px">ðŸ™‚</span> Amazon Subscribe & Save</h1>
    <span class="sync-dot" id="syncDot" title="Offline"></span>
  </div>
  <div class="subtitle">March 10, 2026 Delivery &mdash; <span id="itemCount">44</span> items</div>
  <div class="deadline">Last day to edit: Wednesday, March 4</div>

  <!-- Spending Dashboard -->
  <div class="dashboard" id="dashboard">
    <div class="dashboard-header" onclick="toggleDashboard()">
      <h2>Spending Dashboard</h2>
      <span class="dashboard-toggle" id="dashToggle">Show</span>
    </div>
    <div class="dashboard-body" id="dashBody">
      <div class="dash-grid" id="dashGrid"></div>
      <div class="dash-categories" id="dashCategories"></div>
    </div>
  </div>

  <!-- Price Alerts -->
  <div class="alerts-section" id="alertsSection" style="display:none"></div>

  <!-- Frequency Mismatches (hidden) -->
  <div class="freq-recs" id="freqRecs" style="display:none"></div>

  <!-- Implementation Progress -->
  <div class="progress-section" id="progressSection">
    <div class="progress-label" id="progressLabel">Implementing changes...</div>
    <div class="progress-bar-track"><div class="progress-bar-fill" id="progressFill"></div></div>
    <div class="progress-detail" id="progressDetail"></div>
  </div>

  <div class="controls">
    <button onclick="selectAll()">Select All</button>
    <button onclick="deselectAll()">Deselect All</button>
    <!-- Sort is always by urgency (most likely to order first) -->
    <button class="primary" onclick="saveSelections()">Save</button>
    <button class="danger" onclick="showImplementModal()">Implement</button>
    <input type="text" class="search" placeholder="Filter items..." oninput="filterItems(this.value)">
  </div>

  <div class="summary" id="summary"></div>

  <ul class="item-list" id="itemList"></ul>

  <div class="deletion-section" id="deletionSection" style="display:none">
    <div class="deletion-header">Deletion Candidates</div>
    <div id="deletionList"></div>
  </div>

  <div class="toast" id="toast"></div>

  <!-- Implement Confirmation Modal -->
  <div class="modal-overlay" id="implementModal">
    <div class="modal">
      <h2>Confirm Implementation</h2>
      <p style="font-size:0.85rem;color:#777;margin-bottom:12px">The following actions will be performed on your Amazon S&S account:</p>
      <div class="modal-actions" id="modalActions"></div>
      <div class="modal-buttons">
        <button class="btn-cancel" onclick="closeImplementModal()">Cancel</button>
        <button class="btn-confirm" onclick="executeImplement()">Confirm & Execute</button>
      </div>
    </div>
  </div>

  <script>
    // ========== Item Data ==========
    const items = [
      { id: 13, name: "Presto! Toilet Paper (24 Family Mega Rolls)", price: "$24.64", qty: 3, freq: "1 month", category: "household", alternatives: [] },
      { id: 43, name: "Lavazza Espresso Whole Bean Coffee (2-pack)", price: "$34.19", qty: 2, freq: "1 month", category: "food", alternatives: [] },
      { id: 32, name: "Purina Friskies Variety Pack Cat Food (40 cans)", price: "$31.12", qty: 2, freq: "1 month", category: "pet", alternatives: [] },
      { id: 18, name: "Purina Friskies Shreds Cat Food (24 cans)", price: "$19.15", qty: 2, freq: "1 month", category: "pet", alternatives: [] },
      { id: 5, name: "Presto! Paper Towels (12 Huge Rolls)", price: "$25.49", qty: 1, freq: "1 month", category: "household", alternatives: [] },
      { id: 35, name: "Blue Diamond Dark Chocolate Almonds (25 oz)", price: "$9.76", qty: 2, freq: "1 month", category: "food", alternatives: [] },
      { id: 10, name: "Purina Cat Chow Naturals Indoor (13 lb)", price: "$16.13", qty: 1, freq: "1 month", category: "pet", alternatives: [] },
      { id: 20, name: "Terrasoul Organic Sunflower Seeds (2 lbs)", price: "$13.49", qty: 1, freq: "1 month", category: "food", alternatives: [] },
      { id: 31, name: "Happy Belly Roasted Almonds (24 oz)", price: "$7.56", qty: 1, freq: "1 month", category: "food", alternatives: [] },
      { id: 22, name: "Blue Diamond Wasabi & Soy Sauce Almonds (16 oz)", price: "$6.79", qty: 1, freq: "1 month", category: "food", alternatives: [] },
      { id: 30, name: "Purina ONE Dog Food Beef & Salmon (27.5 lb)", price: "", qty: 1, freq: "1 month", category: "pet", alternatives: [] },
      { id: 29, name: "Har Bracha Tahini Paste (12 pack)", price: "$94.97", qty: 1, freq: "2 months", category: "food", alternatives: [] },
      { id: 3, name: "Lavazza Super Crema Whole Bean Coffee (2.2 lb)", price: "$31.43", qty: 1, freq: "2 months", category: "food", alternatives: [] },
      { id: 1, name: "Mucinex 12 Hour Maximum Strength 1200mg (48 tablets)", price: "$27.79", qty: 1, freq: "2 months", category: "personal", alternatives: [] },
      { id: 28, name: "PUREPLUS 9690 Refrigerator Water Filter (4 pack)", price: "$27.38", qty: 1, freq: "2 months", category: "household", alternatives: [] },
      { id: 41, name: "Amazon Basics Liquid Hand Soap Refill (2-pack)", price: "$8.02", qty: 1, freq: "2 months", category: "household", alternatives: [] },
      { id: 33, name: "Downy CALM Mega Dryer Sheets Lavender (130 ct)", price: "$7.35", qty: 1, freq: "2 months", category: "household", alternatives: [] },
      { id: 9, name: "Hill's Prescription Diet t/d Cat Food (8.5 lb)", price: "", qty: 1, freq: "2 months", category: "pet", alternatives: [] },
      { id: 14, name: "Gillette Clinical Deodorant Cool Wave (3-pack)", price: "$43.32", qty: 2, freq: "3 months", category: "personal", alternatives: [] },
      { id: 40, name: "Endangered Species Dark Chocolate 88% (12 bars)", price: "$47.49", qty: 1, freq: "3 months", category: "food", alternatives: [] },
      { id: 26, name: "Triple Strength Fish Oil Omega 3 (180 softgels)", price: "$45.01", qty: 1, freq: "3 months", category: "personal", alternatives: [] },
      { id: 47, name: "Brawny Tear-A-Square Paper Towels (12 XL Rolls)", price: "$26.77", qty: 1, freq: "3 months", category: "household", alternatives: [] },
      { id: 21, name: "Energizer Ultimate Lithium 9V (2 pack)", price: "$26.50", qty: 1, freq: "3 months", category: "household", alternatives: [] },
      { id: 27, name: "Vicks VapoShower Plus (12 count)", price: "$21.79", qty: 1, freq: "3 months", category: "personal", alternatives: [] },
      { id: 39, name: "GUM Soft-Picks Advanced (90ct, 3-pack)", price: "$19.79", qty: 1, freq: "5 months", category: "personal", alternatives: [] },
      { id: 46, name: "Biotrue Contact Solution (10oz, 2-pack)", price: "$14.44", qty: 1, freq: "5 months", category: "personal", alternatives: [] },
      { id: 25, name: "Scotch Magic Tape (6 rolls w/ dispensers)", price: "$13.33", qty: 1, freq: "4 months", category: "household", alternatives: [] },
      { id: 45, name: "Gillette Clinical Deodorant Arctic Ice (2.6 oz)", price: "$11.02", qty: 8, freq: "6 months", category: "personal", alternatives: [] },
      { id: 36, name: "Dr. Elsey's Ultra Unscented Cat Litter (40 lb)", price: "$20.69", qty: 4, freq: "6 months", category: "pet", alternatives: [] },
      { id: 19, name: "Nautica Voyage EDT (6.7 oz)", price: "$25.37", qty: 1, freq: "6 months", category: "personal", alternatives: [] },
      { id: 8, name: "Nescafe Taster's Choice Instant Coffee (2x 7oz)", price: "$22.92", qty: 1, freq: "6 months", category: "food", alternatives: [] },
      { id: 12, name: "Sensodyne Pronamel Whitening Toothpaste (4-pack)", price: "$21.24", qty: 1, freq: "6 months", category: "personal", alternatives: [] },
      { id: 7, name: "Gillette ProGlide Razor Refills (8 count)", price: "$19.76", qty: 1, freq: "6 months", category: "personal", alternatives: [] },
      { id: 15, name: "Lysol Disinfectant Wipes (4-pack)", price: "$19.65", qty: 1, freq: "6 months", category: "household", alternatives: [] },
      { id: 6, name: "Febreze AIR Linen & Sky (6-pack)", price: "$18.94", qty: 1, freq: "6 months", category: "household", alternatives: [] },
      { id: 2, name: "CeraVe Foaming Facial Cleanser (19 oz)", price: "$15.27", qty: 1, freq: "6 months", category: "personal", alternatives: [] },
      { id: 11, name: "Energizer 123 Lithium Batteries (6 pack)", price: "$11.05", qty: 1, freq: "6 months", category: "household", alternatives: [] },
      { id: 38, name: "Oral-B Glide Floss Pro-Health Mint (3-pack)", price: "$9.47", qty: 1, freq: "6 months", category: "personal", alternatives: [] },
      { id: 16, name: "O'Keeffe's Working Hands (3.4 oz)", price: "$9.13", qty: 1, freq: "6 months", category: "personal", alternatives: [] },
      { id: 23, name: "Carlyle Melatonin 12mg (180 tablets)", price: "$8.54", qty: 1, freq: "6 months", category: "personal", alternatives: [] },
      { id: 34, name: "Dove White Peach Body Scrub (15 oz)", price: "$6.77", qty: 1, freq: "6 months", category: "personal", alternatives: [] },
      { id: 4, name: "Energizer 2032 Batteries (2 count)", price: "$3.82", qty: 1, freq: "6 months", category: "household", alternatives: [] },
      { id: 17, name: "Reynolds Quick Cut Plastic Wrap (225 sq ft)", price: "$3.39", qty: 1, freq: "6 months", category: "household", alternatives: [] },
      { id: 42, name: "Lebanon Valley Tahineh (32 oz)", price: "", qty: 1, freq: "", note: "unavailable", category: "food", alternatives: [] },
    ];

    // ========== Category Labels ==========
    const CATEGORY_LABELS = {
      pet: 'Pet', food: 'Food & Beverage', household: 'Household', personal: 'Personal Care'
    };

    // ========== Store Shopping Habits ==========
    // How often you visit each store (in days). Used to determine if a competitor
    // recommendation is practical â€” no point suggesting Target if you rarely go.
    // Amazon S&S is auto-delivered so it's always "compatible".
    const STORE_HABITS = {
      amazon:  { visitDays: 0,   label: 'Auto-delivered',    practical: true },
      costco:  { visitDays: 7,   label: 'Shop weekly',       practical: true },
      target:  { visitDays: 30,  label: 'Shop occasionally', practical: true },
      walmart: { visitDays: 30,  label: 'Shop occasionally', practical: true },
      sams:    { visitDays: null, label: 'No membership',    practical: false },
    };

    // Minimum annual savings to recommend switching away from S&S auto-delivery
    const MIN_SAVINGS_TO_SWITCH = {
      amazon: 0,     // any savings from an Amazon alt is worth it (same convenience)
      costco: 5,     // $5/yr min â€” you're there weekly anyway
      target: 15,    // $15/yr min â€” need to remember to buy
      walmart: 15,   // same
      sams: Infinity, // never recommend (no membership)
    };

    // ========== Helpers ==========
    function parseFreqMonths(freq) {
      if (!freq) return Infinity;
      const match = freq.match(/(\d+)\s*month/);
      return match ? parseInt(match[1]) : Infinity;
    }

    function parseFreqDays(freq) {
      const m = parseFreqMonths(freq);
      return m === Infinity ? null : m * 30;
    }

    function totalCost(item) {
      const p = parseFloat(item.price.replace('$', ''));
      return isNaN(p) ? 0 : p * item.qty;
    }

    function monthlyEquivalent(item) {
      const m = parseFreqMonths(item.freq);
      if (m === Infinity) return 0;
      return totalCost(item) / m;
    }

    function freqGroupKey(item) {
      const m = parseFreqMonths(item.freq);
      if (m >= 1 && m <= 3) return m;
      if (m >= 4 && m <= 5) return 4;
      if (m === 6) return 6;
      return 99;
    }

    function freqGroupLabel(key) {
      return { 1: 'Every month', 2: 'Every 2 months', 3: 'Every 3 months', 4: 'Every 4\u20135 months', 6: 'Every 6 months', 99: 'Special' }[key] || 'Other';
    }

    // ========== Urgency Scoring ==========
    function computeUrgency(item) {
      const oh = orderHistory[item.id];
      if (!oh || !oh.lastOrdered || !oh.avgIntervalDays) {
        // Fallback: frequency-based
        const m = parseFreqMonths(item.freq);
        if (m <= 1) return { score: 0.9, label: 'Order', tier: 'due-soon' };
        if (m <= 3) return { score: 0.5, label: 'Review', tier: 'maybe' };
        return { score: 0.2, label: 'Skip', tier: 'stock-ok' };
      }

      // Recompute daysSinceLast from live date (Firebase value may be stale)
      const daysSinceLast = Math.round((Date.now() - new Date(oh.lastOrdered).getTime()) / 86400000);
      const score = daysSinceLast / oh.avgIntervalDays;

      if (score >= 0.8) return { score, label: 'Order', tier: 'due-soon' };
      if (score >= 0.5) return { score, label: 'Review', tier: 'maybe' };
      return { score, label: 'Skip', tier: 'stock-ok' };
    }

    function predictNextDate(item) {
      const oh = orderHistory[item.id];
      if (!oh || !oh.lastOrdered) return null;
      const interval = oh.avgIntervalDays || parseFreqDays(item.freq);
      if (!interval) return null;
      const last = new Date(oh.lastOrdered);
      const next = new Date(last.getTime() + interval * 86400000);
      return next;
    }

    function formatShortDate(d) {
      if (!d) return '';
      const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
      return months[d.getMonth()] + ' ' + d.getDate();
    }

    // ========== Auto-Forecast & Pre-Selection ==========
    /**
     * Automatically selects items predicted to be needed based on order history.
     * Called when orderHistory loads from Firebase.
     * Items with urgency >= 0.8 (due soon) are checked; others unchecked.
     * User's manual overrides are preserved via localStorage flag.
     */
    function autoForecastSelections() {
      // Check if user has manually edited selections since last forecast
      const lastForecast = localStorage.getItem('sns-last-forecast');
      const now = new Date().toISOString().slice(0, 10);

      // Only auto-forecast once per day (user edits persist within the day)
      if (lastForecast === now) return;

      let changed = false;
      for (const item of items) {
        const urg = computeUrgency(item);
        const shouldSelect = urg.score >= 0.8; // "Likely Needed" threshold
        if (state[item.id] !== shouldSelect) {
          state[item.id] = shouldSelect;
          changed = true;
        }
      }

      if (changed) {
        saveState();
        if (firebaseReady) {
          const u = {};
          items.forEach(i => { u[i.id] = state[i.id] || false; });
          selectionsRef.set(u);
        }
        localStorage.setItem('sns-last-forecast', now);
        renderAll();
      }
    }

    // ========== Firebase ==========
    const firebaseConfig = {
      apiKey: "AIzaSyDmkRRociBxezM-EMquIZEhClIt9QKNEJo",
      authDomain: "sns-ibendavi.firebaseapp.com",
      databaseURL: "https://amazon-sns-ibendavi-default-rtdb.firebaseio.com",
      projectId: "amazon-sns-ibendavi",
      storageBucket: "amazon-sns-ibendavi.firebasestorage.app",
      messagingSenderId: "220407199939",
      appId: "1:220407199939:web:22bd1bb1ffa53bb8e6ca76"
    };

    let db = null;
    let selectionsRef = null;
    let sendQueueRef = null;
    let cancelQueueRef = null;
    let priceDataRef = null;
    let competitorPricesRef = null;
    let priceHistoryRef = null;
    let implementStatusRef = null;
    let alertsRef = null;
    let firebaseReady = false;

    function initFirebase() {
      if (!firebaseConfig.apiKey) return;
      try {
        firebase.initializeApp(firebaseConfig);
        firebase.auth().signInAnonymously().then(() => {
          db = firebase.database();
          selectionsRef = db.ref('selections');
          sendQueueRef = db.ref('sendQueue');
          cancelQueueRef = db.ref('cancelQueue');
          priceDataRef = db.ref('priceData');
          competitorPricesRef = db.ref('competitorPrices');
          priceHistoryRef = db.ref('priceHistory');
          implementStatusRef = db.ref('implementStatus');
          alertsRef = db.ref('alerts');
          firebaseReady = true;

          // Connection status
          db.ref('.info/connected').on('value', snap => {
            const dot = document.getElementById('syncDot');
            if (snap.val() === true) {
              dot.classList.add('connected');
              dot.title = 'Synced';
            } else {
              dot.classList.remove('connected');
              dot.title = 'Offline';
            }
          });

          // Selections sync
          selectionsRef.on('value', snapshot => {
            const data = snapshot.val();
            if (!data) return;
            let changed = false;
            items.forEach(item => {
              if (data[item.id] !== undefined && state[item.id] !== data[item.id]) {
                state[item.id] = data[item.id];
                changed = true;
              }
            });
            if (changed) {
              saveToLocalStorage();
              renderItems(currentFilter());
            }
          });

          // Cancel queue sync
          cancelQueueRef.on('value', snapshot => {
            const data = snapshot.val();
            if (data) {
              cancelQueue = data;
              localStorage.setItem('sns-cancel-queue', JSON.stringify(cancelQueue));
              renderItems(currentFilter());
            }
          });

          // Price data
          priceDataRef.on('value', snapshot => {
            const data = snapshot.val();
            if (!data) return;
            priceData = data;
            items.forEach(item => {
              const pd = priceData[item.id];
              if (pd) {
                if (pd.alternatives && pd.alternatives.length > 0) item.alternatives = pd.alternatives;
                if (pd.snsPrice && !item.price) item.price = '$' + pd.snsPrice.toFixed(2);
              }
            });
            renderAll();
          });

          // Item ASINs
          db.ref('itemConfig').on('value', snapshot => {
            const data = snapshot.val();
            if (!data) return;
            itemAsins = {};
            for (const [id, config] of Object.entries(data)) {
              if (config.asin) itemAsins[id] = config.asin;
            }
            renderItems(currentFilter());
          });

          // Alt preferences sync
          db.ref('altPreferences').on('value', snapshot => {
            const data = snapshot.val();
            if (!data) return;
            altPreferences = data;
            localStorage.setItem('sns-alt-prefs', JSON.stringify(altPreferences));
            renderItems(currentFilter());
          });

          // Order history
          db.ref('orderHistory').on('value', snapshot => {
            const data = snapshot.val();
            if (!data) return;
            orderHistory = data;
            autoForecastSelections();
            renderAll();
          });

          // Competitor prices
          competitorPricesRef.on('value', snapshot => {
            const data = snapshot.val();
            if (!data) return;
            competitorPrices = data;
            renderItems(currentFilter());
          });

          // Price history (for trends)
          priceHistoryRef.on('value', snapshot => {
            const data = snapshot.val();
            if (!data) return;
            priceHistory = data;
            renderItems(currentFilter());
          });

          // Alerts
          alertsRef.on('value', snapshot => {
            const data = snapshot.val();
            alerts = data || {};
            renderAlerts();
          });

          // Implementation status
          implementStatusRef.on('value', snapshot => {
            const data = snapshot.val();
            if (!data) {
              document.getElementById('progressSection').classList.remove('active');
              return;
            }
            implementStatus = data;
            renderProgress();
          });

          // Push current state
          const updates = {};
          items.forEach(item => { updates[item.id] = !!state[item.id]; });
          selectionsRef.update(updates);
          if (Object.keys(cancelQueue).length > 0) cancelQueueRef.update(cancelQueue);
          if (Object.keys(altPreferences).length > 0) db.ref('altPreferences').update(altPreferences);
        }).catch(err => console.warn('Firebase auth failed:', err));
      } catch (e) {
        console.warn('Firebase not configured:', e.message);
      }
    }

    // ========== State Management ==========
    function defaultState() {
      const st = {};
      items.forEach(item => {
        const m = parseFreqMonths(item.freq);
        st[item.id] = (m <= 3);
      });
      return st;
    }

    function encodeState(st) {
      return items.filter(i => !st[i.id]).map(i => i.id).join(',');
    }

    function decodeHash(hash) {
      const st = {};
      items.forEach(i => st[i.id] = true);
      if (hash) {
        hash.split(',').forEach(s => {
          const n = parseInt(s);
          if (!isNaN(n)) st[n] = false;
        });
      }
      return st;
    }

    function loadState() {
      const hash = window.location.hash;
      if (hash.startsWith('#s=')) {
        const st = decodeHash(hash.substring(3));
        localStorage.setItem('sns-selections', JSON.stringify(st));
        return st;
      }
      const saved = localStorage.getItem('sns-selections');
      if (saved) return JSON.parse(saved);
      return defaultState();
    }

    function saveToLocalStorage() {
      localStorage.setItem('sns-selections', JSON.stringify(state));
    }

    function saveState() {
      saveToLocalStorage();
      const enc = encodeState(state);
      history.replaceState(null, '', enc ? '#s=' + enc : window.location.pathname);
    }

    let state = loadState();
    let altPreferences = JSON.parse(localStorage.getItem('sns-alt-prefs') || '{}');
    let cancelQueue = JSON.parse(localStorage.getItem('sns-cancel-queue') || '{}');
    let priceData = {};
    let itemAsins = {};
    let orderHistory = {};
    let competitorPrices = {};
    let priceHistory = {};
    let alerts = {};
    let implementStatus = {};
    let sortMode = 'urgency'; // 'frequency' or 'urgency'

    window.addEventListener('hashchange', () => {
      state = loadState();
      renderItems(currentFilter());
    });

    // ========== Spending Dashboard ==========
    function computeDashboard() {
      const kept = items.filter(i => state[i.id]);
      const thisDelivery = kept.reduce((sum, i) => sum + totalCost(i), 0);
      const monthlySpend = items.reduce((sum, i) => sum + monthlyEquivalent(i), 0);
      const annualSpend = monthlySpend * 12;

      // S&S savings vs one-time prices
      let snsSavings = 0;
      items.forEach(item => {
        const pd = priceData[item.id];
        if (pd && pd.snsPrice && pd.oneTimePrice && pd.oneTimePrice > pd.snsPrice) {
          const freqMonths = parseFreqMonths(item.freq);
          if (freqMonths !== Infinity) {
            snsSavings += (pd.oneTimePrice - pd.snsPrice) * item.qty * (12 / freqMonths);
          }
        }
      });

      // Potential savings from recommendations (uses same logic as recommendation engine)
      let potentialSavings = 0;
      items.forEach(item => {
        const allAlts = getAllAlternatives(item);
        const rec = buildRecommendation(item, allAlts);
        if (rec && rec.action !== 'keep') {
          const pd = priceData[item.id];
          const dashAmazonUP = parseAmazonUnitPrice(pd?.unitPrice);
          const currentUP = pd?.computedUnitPriceNum || (dashAmazonUP ? dashAmazonUP.value : null);
          const currentUnit = pd?.computedUnit || (dashAmazonUP ? dashAmazonUP.label : null);
          const currentPrice = parseFloat(item.price.replace('$', '')) || null;
          const freqMonths = parseFreqMonths(item.freq);
          if (freqMonths === Infinity) return;

          if (rec.alt.comparableUnitPrice && currentUP && currentUnit) {
            const unitDiff = currentUP - rec.alt.comparableUnitPrice;
            if (unitDiff > 0) {
              const pctSaving = unitDiff / currentUP;
              potentialSavings += pctSaving * (currentPrice || 0) * item.qty * (12 / freqMonths);
            }
          } else if (!currentUnit && !pd?.unitPrice && rec.alt.priceNum && currentPrice && rec.alt.priceNum < currentPrice) {
            potentialSavings += (currentPrice - rec.alt.priceNum) * item.qty * (12 / freqMonths);
          }
        }
      });

      // Category breakdown
      const categories = {};
      items.forEach(item => {
        const cat = item.category || 'other';
        if (!categories[cat]) categories[cat] = 0;
        categories[cat] += monthlyEquivalent(item);
      });

      return { thisDelivery, monthlySpend, annualSpend, snsSavings, potentialSavings, categories };
    }

    function renderDashboard() {
      const d = computeDashboard();
      document.getElementById('dashGrid').innerHTML = `
        <div class="dash-card"><div class="dash-value">$${d.thisDelivery.toFixed(2)}</div><div class="dash-label">This Delivery</div></div>
        <div class="dash-card"><div class="dash-value">$${d.monthlySpend.toFixed(0)}</div><div class="dash-label">Monthly Estimate</div></div>
        <div class="dash-card"><div class="dash-value">$${d.annualSpend.toFixed(0)}</div><div class="dash-label">Annual Projected</div></div>
        <div class="dash-card"><div class="dash-value" style="color:#1e7e34">$${d.snsSavings.toFixed(0)}</div><div class="dash-label">S&S Savings / Year</div></div>
        <div class="dash-card"><div class="dash-value" style="color:#146eb4">$${d.potentialSavings.toFixed(0)}</div><div class="dash-label">Potential Savings</div></div>
      `;

      const catHtml = Object.entries(d.categories)
        .sort((a, b) => b[1] - a[1])
        .map(([cat, monthly]) => `<div class="cat-row"><span>${CATEGORY_LABELS[cat] || cat}</span><span>$${monthly.toFixed(0)}/mo ($${(monthly * 12).toFixed(0)}/yr)</span></div>`)
        .join('');
      document.getElementById('dashCategories').innerHTML = catHtml ? `<h3>By Category</h3>${catHtml}` : '';
    }

    function toggleDashboard() {
      const body = document.getElementById('dashBody');
      const toggle = document.getElementById('dashToggle');
      body.classList.toggle('open');
      toggle.textContent = body.classList.contains('open') ? 'Hide' : 'Show';
      if (body.classList.contains('open')) renderDashboard();
    }

    // ========== Forecast Summary ==========
    function renderForecastSummary() {
      const section = document.getElementById('freqRecs');

      // Find items where predicted frequency differs significantly from S&S setting
      const mismatches = [];
      for (const item of items) {
        const oh = orderHistory[item.id];
        if (!oh || !oh.avgIntervalDays) continue;
        const subDays = parseFreqDays(item.freq);
        if (!subDays) continue;
        const actual = oh.avgIntervalDays;
        const diff = actual - subDays;
        // Flag if >30% mismatch
        if (Math.abs(diff) > subDays * 0.3) {
          const predictedFreq = actual < 25 ? '~' + actual + ' days'
            : actual < 50 ? '~' + Math.round(actual / 7) + ' weeks'
            : '~' + Math.round(actual / 30) + ' months';
          mismatches.push({ item, actual, subDays, predictedFreq, diff });
        }
      }

      if (mismatches.length === 0) {
        section.style.display = 'none';
        return;
      }

      // Sort by biggest mismatch first
      mismatches.sort((a, b) => Math.abs(b.diff) - Math.abs(a.diff));

      section.style.display = 'block';
      section.innerHTML = `
        <h3>Frequency Mismatches (${mismatches.length})</h3>
        ${mismatches.slice(0, 5).map(m => {
          const action = m.diff > 0 ? 'Slow down' : 'Speed up';
          const savingsNote = m.diff > 0
            ? `You use this every ${m.predictedFreq} but S&S delivers every ${m.item.freq}. Consider switching to a longer interval.`
            : `You use this every ${m.predictedFreq} but S&S delivers every ${m.item.freq}. Consider switching to a shorter interval.`;
          return `<div class="freq-rec-card">
            <div class="rec-title">${action}: ${m.item.name.substring(0, 50)}</div>
            <div class="rec-detail">${savingsNote}</div>
          </div>`;
        }).join('')}
      `;
    }

    // ========== Price Alerts ==========
    function renderAlerts() {
      const section = document.getElementById('alertsSection');
      const alertList = Object.entries(alerts).filter(([id, a]) => a && !a.dismissed);
      if (alertList.length === 0) {
        section.style.display = 'none';
        return;
      }
      section.style.display = 'block';
      section.innerHTML = alertList.map(([id, a]) => `
        <div class="alert-card">
          <div class="alert-title">${a.type === 'price_drop' ? 'Price Drop' : 'Alert'}: ${a.itemName || 'Item ' + id}</div>
          <div class="alert-detail">${a.message || ''}</div>
        </div>
      `).join('');
    }

    // ========== Competitor + All Alternatives ==========
    function getAllAlternatives(item) {
      const all = [];
      const pd = priceData[item.id];
      const currentUnit = pd?.computedUnit || null; // e.g. "roll", "oz", "can"
      // Fallback: parse Amazon's own unit price string (e.g. "$1.58/100 Sheets")
      const currentAmazonUP = !currentUnit ? parseAmazonUnitPrice(pd?.unitPrice) : null;

      // Amazon alternatives from priceData
      if (item.alternatives) {
        item.alternatives.forEach(alt => {
          // Prefer our computed unit price (same unit system as current item)
          const hasMatchingUnit = alt.computedUnit && alt.computedUnit === currentUnit;
          // Fallback: Amazon's own unit prices match (e.g. both "100 Sheets")
          const altAmazonUP = !hasMatchingUnit && currentAmazonUP ? parseAmazonUnitPrice(alt.unitPrice) : null;
          const amazonUnitsMatch = altAmazonUP && currentAmazonUP && altAmazonUP.label === currentAmazonUP.label;

          const displayUnitPrice = hasMatchingUnit
            ? alt.computedUnitPrice
            : (alt.computedUnitPrice || alt.unitPrice || '');

          all.push({
            ...alt,
            store: 'amazon',
            priceNum: parseFloat((alt.price || '').replace('$', '')) || null,
            comparableUnitPrice: hasMatchingUnit ? alt.computedUnitPriceNum
              : (amazonUnitsMatch ? altAmazonUP.value : null),
            comparableUnit: hasMatchingUnit ? alt.computedUnit
              : (amazonUnitsMatch ? currentAmazonUP.label : null),
            displayUnitPrice,
          });
        });
      }

      // Competitor prices
      const comp = competitorPrices[item.id];
      if (comp) {
        for (const [store, data] of Object.entries(comp)) {
          if (!data || !data.price) continue;
          // Prefer computed unit (same logic as Amazon) over store-provided unit
          const compUnit = data.computedUnit || null;
          const compUnitPrice = data.computedUnitPriceNum || null;
          const hasMatchingUnit = compUnit && compUnit === currentUnit;
          // Display: prefer computed, fall back to store-provided
          const dispUnit = data.computedUnitPrice
            || (data.unitPrice ? `$${data.unitPrice}/${data.unit || 'ea'}` : '');
          all.push({
            name: data.name,
            price: '$' + (typeof data.price === 'number' ? data.price.toFixed(2) : data.price),
            priceNum: typeof data.price === 'number' ? data.price : parseFloat(String(data.price).replace('$', '')),
            displayUnitPrice: dispUnit,
            comparableUnitPrice: hasMatchingUnit ? compUnitPrice : null,
            comparableUnit: hasMatchingUnit ? compUnit : null,
            url: data.url,
            image: data.image || '',
            store,
            asin: null,
          });
        }
      }

      return all;
    }

    function parseUnitPrice(str) {
      if (!str) return null;
      const m = String(str).match(/\$?([\d.]+)/);
      return m ? parseFloat(m[1]) : null;
    }

    // Parse Amazon unit price strings like "$1.58/100 Sheets" â†’ { value: 1.58, label: "100 Sheets" }
    function parseAmazonUnitPrice(str) {
      if (!str) return null;
      const m = String(str).match(/\$?([\d.]+)\s*\/\s*(.+)/);
      if (!m) return null;
      return { value: parseFloat(m[1]), label: m[2].trim().toLowerCase() };
    }

    function findBestValue(alts, currentItem) {
      const pd = priceData[currentItem.id];
      const currentAmazonUP = parseAmazonUnitPrice(pd?.unitPrice);
      const currentUnit = pd?.computedUnit || (currentAmazonUP ? currentAmazonUP.label : null);
      const currentComparableUnitPrice = pd?.computedUnitPriceNum || (currentAmazonUP ? currentAmazonUP.value : null);
      const currentPrice = parseFloat(currentItem.price.replace('$', '')) || null;
      // Item has a unit concept if it has computedUnit OR Amazon's own unitPrice
      const hasUnitConcept = currentUnit || pd?.unitPrice;

      // Strategy 1: Compare by unit price (same unit only)
      const sameUnitAlts = alts.filter(a => a.comparableUnitPrice && a.comparableUnit === currentUnit);
      if (sameUnitAlts.length > 0 && currentComparableUnitPrice) {
        let best = null;
        let bestUP = currentComparableUnitPrice;
        for (const a of sameUnitAlts) {
          if (a.comparableUnitPrice < bestUP) {
            bestUP = a.comparableUnitPrice;
            best = a;
          }
        }
        return best; // null = current item is best per unit
      }

      // Strategy 2: Total price comparison â€” ONLY when no unit data exists at all.
      // If the item has ANY unit info (computed or Amazon's own), total price comparison
      // is invalid because competitors may be a completely different quantity.
      if (hasUnitConcept) return null;

      if (!currentPrice) return null;
      let best = null;
      let bestPrice = currentPrice;
      for (const a of alts) {
        if (a.priceNum && a.priceNum < bestPrice) {
          bestPrice = a.priceNum;
          best = a;
        }
      }
      return best; // null means current item is cheapest
    }

    // ========== Recommendation Engine ==========
    function computeAnnualSavings(currentPrice, altPrice, qty, freqMonths) {
      if (!altPrice || !currentPrice || freqMonths === Infinity) return null;
      return (currentPrice - altPrice) * qty * (12 / freqMonths);
    }

    function isStoreCompatible(store, itemFreqDays) {
      const habit = STORE_HABITS[store];
      if (!habit || !habit.practical) return false;
      if (store === 'amazon') return true; // auto-delivered, always compatible
      if (habit.visitDays === null) return false;
      // You visit often enough to buy this item on your regular trips
      return habit.visitDays <= (itemFreqDays || 30);
    }

    function buildRecommendation(item, allAlts) {
      const pd = priceData[item.id];
      const currentPrice = parseFloat(item.price.replace('$', '')) || null;
      if (!currentPrice && !pd?.computedUnitPriceNum) return null;

      const currentAmazonUP = parseAmazonUnitPrice(pd?.unitPrice);
      const currentUnit = pd?.computedUnit || (currentAmazonUP ? currentAmazonUP.label : null);
      const currentUP = pd?.computedUnitPriceNum || (currentAmazonUP ? currentAmazonUP.value : null);
      // Item has a unit concept if it has computedUnit OR Amazon's own unitPrice
      const hasUnitConcept = currentUnit || pd?.unitPrice;
      const freqMonths = parseFreqMonths(item.freq);
      const freqDays = parseFreqDays(item.freq);

      // Score each alternative considering price AND store practicality
      const candidates = [];
      for (const alt of allAlts) {
        const store = alt.store;
        const habit = STORE_HABITS[store] || STORE_HABITS.amazon;
        const compatible = isStoreCompatible(store, freqDays);
        const minSavings = MIN_SAVINGS_TO_SWITCH[store] ?? 15;

        // Compute per-unit savings if same unit
        let unitSavings = null;
        if (alt.comparableUnitPrice && currentUP && alt.comparableUnit === currentUnit) {
          unitSavings = currentUP - alt.comparableUnitPrice;
        }

        // Compute annual savings â€” use unit-price-based estimate when available
        let annual = null;
        if (unitSavings && unitSavings > 0 && currentUP > 0 && currentPrice && freqMonths !== Infinity) {
          // Annual savings = (unit saving / current unit price) * current total price * orders/year
          const pctSaving = unitSavings / currentUP;
          annual = pctSaving * currentPrice * item.qty * (12 / freqMonths);
        } else if (!hasUnitConcept) {
          // No unit data at all â€” total price comparison is valid (same product, different sellers)
          annual = computeAnnualSavings(currentPrice, alt.priceNum, item.qty, freqMonths);
        }

        // Skip if store isn't practical or savings too small
        if (!compatible) continue;
        if (annual !== null && annual < minSavings) continue;

        // Must actually be cheaper
        // If the item has ANY unit info, ONLY consider unit-price savings.
        // Total price is meaningless when quantities differ (e.g., 4-roll vs 24-roll).
        let isCheaper = false;
        if (hasUnitConcept) {
          // Unit-price comparison only
          isCheaper = unitSavings && unitSavings > 0.005;
        } else {
          // No unit data â€” fall back to total price
          isCheaper = (alt.priceNum && currentPrice && alt.priceNum < currentPrice);
        }
        if (!isCheaper) continue;

        candidates.push({
          alt,
          store,
          unitSavings,
          annual,
          compatible,
          // Prefer: (1) same-unit cheaper, (2) higher annual savings
          score: (unitSavings && unitSavings > 0 ? unitSavings * 100 : 0) + (annual || 0),
        });
      }

      if (candidates.length === 0) {
        return { action: 'keep', text: 'Your current item is the best value.', savings: null };
      }

      // Pick the best candidate
      candidates.sort((a, b) => b.score - a.score);
      const best = candidates[0];
      const bestAlt = best.alt;
      const storeName = best.store.charAt(0).toUpperCase() + best.store.slice(1);
      const isAmazon = best.store === 'amazon';
      const nameShort = bestAlt.name.length > 60 ? bestAlt.name.slice(0, 57) + '...' : bestAlt.name;
      const storeHabit = STORE_HABITS[best.store];

      // Build savings text
      let savingsText = '';
      if (best.unitSavings && best.unitSavings > 0.005) {
        savingsText = `$${best.unitSavings.toFixed(2)}/${bestAlt.comparableUnit} cheaper`;
      } else if (!hasUnitConcept && bestAlt.priceNum && currentPrice && currentPrice > bestAlt.priceNum) {
        // Only show total-price savings when we have no unit data at all (same product comparison)
        savingsText = `$${(currentPrice - bestAlt.priceNum).toFixed(2)} less per order`;
      }
      if (best.annual && best.annual > 1) {
        savingsText += ` (~$${best.annual.toFixed(0)}/yr)`;
      }

      if (isAmazon) {
        return {
          action: 'switch',
          text: `Switch to ${nameShort}`,
          savings: savingsText,
          alt: bestAlt,
          itemId: item.id,
        };
      } else {
        // Note store visit frequency for context
        const habitNote = storeHabit ? ` \u2014 you shop there ${storeHabit.label.toLowerCase().replace('shop ', '')}` : '';
        return {
          action: 'buy',
          store: storeName,
          text: `Buy at ${storeName}: ${nameShort}`,
          savings: savingsText + habitNote,
          alt: bestAlt,
        };
      }
    }

    // ========== Price Trend ==========
    function getPriceTrend(itemId) {
      const ph = priceHistory[itemId];
      if (!ph) return null;
      const dates = Object.keys(ph).sort();
      if (dates.length < 2) return null;

      const latest = ph[dates[dates.length - 1]];
      const previous = ph[dates[dates.length - 2]];
      const oldest = ph[dates[0]];

      const latestPrice = latest?.snsPrice || latest?.price;
      const previousPrice = previous?.snsPrice || previous?.price;
      const oldestPrice = oldest?.snsPrice || oldest?.price;

      if (!latestPrice || !previousPrice) return null;

      const change = latestPrice - previousPrice;
      const allPrices = dates.map(d => ph[d]?.snsPrice || ph[d]?.price).filter(p => p);
      const minPrice = Math.min(...allPrices);
      const is52wLow = latestPrice <= minPrice * 1.02; // within 2% of lowest

      return {
        direction: change > 0.1 ? 'up' : change < -0.1 ? 'down' : 'flat',
        change: Math.abs(change),
        is52wLow,
        latestPrice,
        minPrice,
      };
    }

    // ========== Rendering ==========
    function currentFilter() {
      const el = document.querySelector('.search');
      return el ? el.value : '';
    }

    function renderAll() {
      renderDashboard();
      // renderForecastSummary(); // disabled â€” freq mismatches shown inline per item
      renderDeletionCandidates();
      renderAlerts();
      renderItems(currentFilter());
    }

    function getSortedItems() {
      if (sortMode === 'urgency') {
        return [...items].sort((a, b) => {
          const ua = computeUrgency(a);
          const ub = computeUrgency(b);
          return ub.score - ua.score;
        });
      }
      return items; // default frequency order
    }

    function urgencyGroupLabel(tier) {
      return { 'due-soon': 'Order Now', 'maybe': 'Review', 'stock-ok': 'Skip' }[tier] || 'Other';
    }

    function renderItems(filter = '') {
      const list = document.getElementById('itemList');
      list.innerHTML = '';
      const lf = filter.toLowerCase();
      let idx = 0;
      let lastGroup = null;

      const sorted = getSortedItems();

      sorted.forEach(item => {
        if (filter && !item.name.toLowerCase().includes(lf)) return;

        // Group dividers
        if (!filter) {
          if (sortMode === 'urgency') {
            const urg = computeUrgency(item);
            if (urg.tier !== lastGroup) {
              lastGroup = urg.tier;
              const div = document.createElement('li');
              div.className = 'group-divider';
              div.textContent = urgencyGroupLabel(urg.tier);
              list.appendChild(div);
            }
          } else {
            const gk = freqGroupKey(item);
            if (gk !== lastGroup) {
              lastGroup = gk;
              const div = document.createElement('li');
              div.className = 'group-divider';
              div.textContent = freqGroupLabel(gk);
              list.appendChild(div);
            }
          }
        }

        idx++;
        const checked = state[item.id];
        const isCancelled = !!cancelQueue[item.id];
        const li = document.createElement('li');
        li.className = 'item' + (checked ? '' : ' unchecked') + (isCancelled ? ' cancelled' : '');

        let noteHtml = '';
        if (item.note === 'unavailable') noteHtml = '<span class="unavailable">Temporarily Unavailable</span>';
        if (item.note === 'vet') noteHtml = '<span class="vet-note">Vet approval required</span>';

        // Alternative preference indicator
        const prefAlt = altPreferences[item.id];
        const prefHtml = prefAlt ? `<span class="pref-alt">\u2192 ${prefAlt}</span>` : '';

        // Urgency badge
        const urg = computeUrgency(item);
        const urgBadge = `<span class="urgency-badge ${urg.tier}">${urg.label}</span>`;

        // Predicted next date
        const nextDate = predictNextDate(item);
        const nextDateHtml = nextDate ? `<span class="next-date">Next: ~${formatShortDate(nextDate)}</span>` : '';

        // Price data badges
        const pd = priceData[item.id];
        let badgeHtml = '';
        if (pd && pd.savingsPct) badgeHtml += `<span class="price-badge">S&amp;S saves ${pd.savingsPct}%</span>`;

        // Unit price display
        const computedUnit = pd?.computedUnitPrice || pd?.unitPrice || '';
        const unitPriceHtml = computedUnit ? `<span class="price-badge">${computedUnit}</span>` : '';

        // Coupon badge
        let couponHtml = '';
        if (pd && pd.coupons && pd.coupons.length > 0) {
          couponHtml = pd.coupons.map(c => `<span class="coupon-badge">${c}</span>`).join(' ');
        }

        // Price trend
        const trend = getPriceTrend(item.id);
        let trendHtml = '';
        if (trend) {
          if (trend.direction === 'down') trendHtml = `<span class="trend-down">\u2193 $${trend.change.toFixed(2)}</span>`;
          else if (trend.direction === 'up') trendHtml = `<span class="trend-up">\u2191 $${trend.change.toFixed(2)}</span>`;
          if (trend.is52wLow) trendHtml += ' <span class="week52-low">52-wk Low</span>';
        }

        // Order history badge â€” show days since last order + avg interval
        const oh = orderHistory[item.id];
        let histBadge = '';
        if (oh && oh.lastOrdered) {
          const daysSince = Math.round((Date.now() - new Date(oh.lastOrdered).getTime()) / 86400000);
          const interval = oh.avgIntervalDays ? `every ~${oh.avgIntervalDays}d` : '';
          const lastDate = formatShortDate(new Date(oh.lastOrdered));
          const title = `${oh.orderCount} orders, last ${lastDate}, avg interval ${oh.avgIntervalDays || '?'} days`;
          histBadge = `<span class="history-badge" title="${title}">${daysSince}d ago${interval ? ' / ' + interval : ''}</span>`;
        }

        // Bulk buy suggestion from priceData
        let bulkHtml = '';
        if (pd && pd.bulkSuggestion) {
          bulkHtml = `<div class="bulk-suggestion">${pd.bulkSuggestion}</div>`;
        }

        // Alternatives section with competitor integration
        const allAlts = getAllAlternatives(item);
        let altHtml = '';
        let recHtml = '';
        if (allAlts.length === 0 && item.price) {
          recHtml = `<div class="recommendation rec-keep"><span class="rec-action keep">Keep</span><span class="rec-detail">No alternatives found. Current item is your best option.</span></div>`;
        }
        if (allAlts.length > 0) {
          const altId = 'alt-' + item.id;
          const bestVal = findBestValue(allAlts, item);

          // Build recommendation (shown outside alt-list, always visible)
          const rec = buildRecommendation(item, allAlts);
          if (rec) {
            if (rec.action === 'keep') {
              recHtml = `<div class="recommendation rec-keep"><span class="rec-action keep">Keep</span><span class="rec-detail">${rec.text}</span></div>`;
            } else if (rec.action === 'switch') {
              const escapedRecName = (rec.alt.name || '').replace(/'/g, "\\'").replace(/"/g, '&quot;');
              const link = rec.alt.asin ? `<a href="https://www.amazon.com/dp/${rec.alt.asin}" target="_blank">${rec.text}</a>` : rec.text;
              const switchBtn = rec.alt.asin ? ` <button class="alt-switch" onclick="switchAlt(${rec.itemId}, '${escapedRecName}')" style="font-size:0.7rem;padding:2px 8px">Switch</button>` : '';
              recHtml = `<div class="recommendation rec-switch"><span class="rec-action switch">Switch</span><span class="rec-detail">${link}${rec.savings ? ' &mdash; <span class="rec-savings">' + rec.savings + '</span>' : ''}${switchBtn}</span></div>`;
            } else if (rec.action === 'buy') {
              const link = rec.alt.url ? `<a href="${rec.alt.url}" target="_blank">${rec.text}</a>` : rec.text;
              recHtml = `<div class="recommendation rec-competitor"><span class="rec-action buy">Buy</span><span class="rec-detail">${link}${rec.savings ? ' &mdash; <span class="rec-savings">' + rec.savings + '</span>' : ''}</span></div>`;
            }
          }

          const betterCount = allAlts.filter(a => {
            const cp = parseFloat(item.price.replace('$', ''));
            return a.priceNum && cp && a.priceNum < cp;
          }).length;
          const storeCount = new Set(allAlts.map(a => a.store)).size;
          const betterLabel = betterCount > 0 ? ` \u2014 ${betterCount} cheaper option${betterCount > 1 ? 's' : ''}` : '';

          altHtml = `<div class="alt-toggle" onclick="toggleAlts('${altId}')">Alternatives (${allAlts.length} from ${storeCount} store${storeCount > 1 ? 's' : ''})${betterLabel}</div>`;
          altHtml += `<div class="alt-list" id="${altId}">`;

          allAlts.forEach(alt => {
            const isAmazon = alt.store === 'amazon';
            const isSelected = isAmazon && altPreferences[item.id] === alt.name;
            const escapedName = (alt.name || '').replace(/'/g, "\\'").replace(/"/g, '&quot;');
            const isBest = bestVal === alt;
            const bestBadge = isBest ? '<span class="alt-recommended">Best value</span>' : '';

            const storeBadgeHtml = `<span class="store-badge ${alt.store}">${alt.store.charAt(0).toUpperCase() + alt.store.slice(1)}</span>`;

            const metaParts = [alt.price];
            if (alt.displayUnitPrice) metaParts.push(alt.displayUnitPrice);

            // Savings: prefer same-unit comparison, fall back to total price
            const currentPrice = parseFloat(item.price.replace('$', ''));
            const pd = priceData[item.id];
            let savingsHtml = '';
            const dispAmazonUP = parseAmazonUnitPrice(pd?.unitPrice);
            const dispCurrentUP = pd?.computedUnitPriceNum || (dispAmazonUP ? dispAmazonUP.value : null);
            const dispCurrentUnit = pd?.computedUnit || (dispAmazonUP ? dispAmazonUP.label : null);
            if (alt.comparableUnitPrice && dispCurrentUP) {
              // Same-unit comparison (computed or Amazon unit price)
              const diff = dispCurrentUP - alt.comparableUnitPrice;
              const unit = alt.comparableUnit;
              if (diff > 0.005) savingsHtml = `<div class="alt-savings">$${diff.toFixed(2)}/${unit} cheaper</div>`;
              else if (diff < -0.005) savingsHtml = `<div class="alt-savings more-expensive">$${Math.abs(diff).toFixed(2)}/${unit} more</div>`;
            } else if (alt.priceNum && currentPrice) {
              // Total price comparison â€” only valid when no unit data (same product type)
              const sizeWarning = (dispCurrentUnit && !alt.comparableUnit) ? ' <span style="color:#999;font-weight:normal">(different size)</span>' : '';
              const diff = currentPrice - alt.priceNum;
              if (Math.abs(diff) > 0.01) {
                if (diff > 0) savingsHtml = `<div class="alt-savings">$${diff.toFixed(2)} less${sizeWarning}</div>`;
                else savingsHtml = `<div class="alt-savings more-expensive">$${Math.abs(diff).toFixed(2)} more${sizeWarning}</div>`;
              } else if (sizeWarning) {
                savingsHtml = `<div class="alt-savings" style="color:#999">Similar price (different size)</div>`;
              }
            }

            // Link/button
            let actionBtn = '';
            if (isAmazon && alt.asin) {
              actionBtn = `<button class="alt-switch${isSelected ? ' selected' : ''}" onclick="switchAlt(${item.id}, '${escapedName}')">${isSelected ? 'Selected' : 'Switch'}</button>`;
            } else if (alt.url) {
              actionBtn = `<a href="${alt.url}" target="_blank" class="alt-link">View \u2192</a>`;
            }

            const nameLink = alt.asin
              ? `<a href="https://www.amazon.com/dp/${alt.asin}" target="_blank" style="color:inherit;text-decoration:none">${alt.name}</a>`
              : alt.url
                ? `<a href="${alt.url}" target="_blank" style="color:inherit;text-decoration:none">${alt.name}</a>`
                : alt.name;

            const imgHtml = alt.image ? `<img class="alt-img" src="${alt.image}" alt="" loading="lazy">` : '';

            altHtml += `
              <div class="alt-item">
                ${imgHtml}
                <div class="alt-info">
                  <div class="alt-name">${storeBadgeHtml} ${nameLink}${bestBadge}</div>
                  <div class="alt-meta">${metaParts.join(' &middot; ')}</div>
                  ${savingsHtml}
                </div>
                ${actionBtn}
              </div>`;
          });

          // Best value summary row
          if (bestVal) {
            const pd = priceData[item.id];
            let saveSummary = '';
            if (bestVal.comparableUnitPrice && pd?.computedUnitPriceNum) {
              const diff = pd.computedUnitPriceNum - bestVal.comparableUnitPrice;
              if (diff > 0) saveSummary = `, saves $${diff.toFixed(2)}/${bestVal.comparableUnit}`;
            } else if (!pd?.computedUnit && !pd?.unitPrice) {
              // Only show total-price savings when no unit data at all
              const currentPrice = parseFloat(item.price.replace('$', ''));
              const saving = currentPrice ? (currentPrice - (bestVal.priceNum || 0)) : 0;
              if (saving > 0) saveSummary = `, saves $${saving.toFixed(2)}/order`;
            }
            const unitLabel = bestVal.displayUnitPrice ? ` (${bestVal.displayUnitPrice})` : '';
            altHtml += `<div class="best-value-row">\u2605 Best value: ${bestVal.store.charAt(0).toUpperCase() + bestVal.store.slice(1)} ${bestVal.name}${unitLabel}${saveSummary}</div>`;
          }

          altHtml += '</div>';
        }

        // Price display with unit price
        const priceDisplay = item.price + (computedUnit ? ` <span style="font-size:0.75rem;color:#777;font-weight:normal">${computedUnit}</span>` : '');

        const itemImage = pd?.image || '';
        const itemImgHtml = itemImage ? `<img class="item-img" src="${itemImage}" alt="" loading="lazy">` : '';

        li.innerHTML = `
          <span class="item-num">${idx}</span>
          <input type="checkbox" ${checked ? 'checked' : ''} onchange="toggle(${item.id}, this.checked)" id="cb-${item.id}">
          ${itemImgHtml}
          <div class="item-details">
            <div class="item-name">${itemAsins[item.id] ? '<a href="https://www.amazon.com/dp/' + itemAsins[item.id] + '" target="_blank" style="color:inherit">' + item.name + '</a>' : item.name}${prefHtml}${isCancelled ? '<span class="cancel-label">Pending cancellation</span>' : ''}</div>
            <div class="item-meta">
              ${(() => {
                const oh = orderHistory[item.id];
                if (oh && oh.avgIntervalDays) {
                  const days = oh.avgIntervalDays;
                  const predictedFreq = days < 25 ? 'Every ~' + days + ' days'
                    : days < 50 ? 'Every ~' + Math.round(days / 7) + ' weeks'
                    : 'Every ~' + Math.round(days / 30) + ' months';
                  const subFreqDays = parseFreqDays(item.freq);
                  const mismatch = subFreqDays && Math.abs(days - subFreqDays) > subFreqDays * 0.3;
                  return predictedFreq + (mismatch ? ' <span style="color:#c62828;font-size:0.7rem" title="S&S set to ' + item.freq + '">(S&S: ' + item.freq + ')</span>' : '');
                }
                return item.freq ? 'Every ' + item.freq : '';
              })()}${item.qty > 1 ? ' &middot; Qty: ' + item.qty : ''}
              ${urgBadge} ${nextDateHtml} ${noteHtml} ${badgeHtml} ${unitPriceHtml} ${couponHtml} ${trendHtml} ${histBadge}
            </div>
            ${bulkHtml}
            ${recHtml}
            ${altHtml}
          </div>
          <span class="item-price">${priceDisplay}</span>
          ${!isCancelled ? `<button class="cancel-btn" onclick="cancelItem(${item.id})" title="Cancel subscription">&times;</button>` : ''}
        `;
        list.appendChild(li);
      });

      document.getElementById('itemCount').textContent = items.length;
      updateSummary();
    }

    // ========== Actions ==========
    function toggle(id, checked) {
      state[id] = checked;
      saveState();
      if (firebaseReady) selectionsRef.child(String(id)).set(checked);
      renderItems(currentFilter());
    }

    function selectAll() {
      items.forEach(i => state[i.id] = true);
      saveState();
      if (firebaseReady) {
        const u = {};
        items.forEach(i => { u[i.id] = true; });
        selectionsRef.update(u);
      }
      renderItems(currentFilter());
    }

    function deselectAll() {
      items.forEach(i => state[i.id] = false);
      saveState();
      if (firebaseReady) {
        const u = {};
        items.forEach(i => { u[i.id] = false; });
        selectionsRef.update(u);
      }
      renderItems(currentFilter());
    }

    function toggleSortMode() {
      sortMode = sortMode === 'frequency' ? 'urgency' : 'frequency';
      const btn = document.getElementById('sortBtn');
      btn.textContent = sortMode === 'urgency' ? 'Freq Sort' : 'Smart Sort';
      btn.classList.toggle('active', sortMode === 'urgency');
      renderItems(currentFilter());
    }

    function updateSummary() {
      const kept = items.filter(i => state[i.id]);
      const skipped = items.filter(i => !state[i.id]);
      const total = kept.reduce((sum, i) => {
        const p = parseFloat(i.price.replace('$', ''));
        return sum + (isNaN(p) ? 0 : p * i.qty);
      }, 0);
      const cancelCount = Object.keys(cancelQueue).length;
      const switchCount = Object.keys(altPreferences).length;
      document.getElementById('summary').innerHTML = `
        <span>${kept.length}</span> items kept &mdash;
        <span>${skipped.length}</span> to skip
        ${switchCount ? ' &mdash; <span>' + switchCount + '</span> switches' : ''}
        ${cancelCount ? ' &mdash; <span style="color:#d32f2f">' + cancelCount + '</span> cancellations' : ''}
        &mdash; Estimated total: <span>$${total.toFixed(2)}</span>
      `;
    }

    function saveSelections() {
      const kept = items.filter(i => state[i.id]).map(i => ({ id: i.id, name: i.name }));
      const skipped = items.filter(i => !state[i.id]).map(i => ({ id: i.id, name: i.name }));
      const payload = {
        selections: Object.assign({}, state),
        altPreferences: Object.assign({}, altPreferences),
        cancelQueue: Object.assign({}, cancelQueue),
        kept,
        skipped,
        timestamp: Date.now(),
        status: 'saved'
      };

      if (firebaseReady) {
        sendQueueRef.set(payload).then(() => {
          showToast('Selections saved to Firebase.');
        }).catch(err => {
          showToast('Error saving: ' + err.message);
        });
      } else {
        navigator.clipboard.writeText(JSON.stringify(payload, null, 2)).then(() => {
          showToast('Copied to clipboard (Firebase offline).');
        }).catch(() => {
          console.log('Save payload:', payload);
          showToast('Logged to console.');
        });
      }
    }

    // ========== Implement Modal ==========
    function buildActionList() {
      const actions = [];

      // Skips
      items.filter(i => !state[i.id] && i.freq).forEach(i => {
        actions.push({ type: 'skip', label: `Skip "${i.name}" from next delivery` });
      });

      // Switches
      Object.entries(altPreferences).forEach(([id, altName]) => {
        const item = items.find(i => i.id === parseInt(id));
        if (item) actions.push({ type: 'switch', label: `Switch "${item.name}" to "${altName}"` });
      });

      // Cancellations
      Object.entries(cancelQueue).forEach(([id, data]) => {
        actions.push({ type: 'cancel', label: `Cancel subscription: "${data.name}"` });
      });

      return actions;
    }

    function showImplementModal() {
      const actions = buildActionList();
      const container = document.getElementById('modalActions');

      if (actions.length === 0) {
        container.innerHTML = '<p style="color:#777;font-size:0.85rem">No changes to implement. Skip items, switch alternatives, or mark cancellations first.</p>';
      } else {
        container.innerHTML = actions.map(a => `
          <div class="modal-action">
            <span class="action-type ${a.type}">${a.type}</span>
            ${a.label}
          </div>
        `).join('');
      }

      document.getElementById('implementModal').classList.add('open');
    }

    function closeImplementModal() {
      document.getElementById('implementModal').classList.remove('open');
    }

    function executeImplement() {
      const actions = buildActionList();
      if (actions.length === 0) {
        closeImplementModal();
        return;
      }

      const payload = {
        selections: Object.assign({}, state),
        altPreferences: Object.assign({}, altPreferences),
        cancelQueue: Object.assign({}, cancelQueue),
        actions,
        timestamp: Date.now(),
        status: 'pending'
      };

      if (firebaseReady) {
        sendQueueRef.set(payload).then(() => {
          closeImplementModal();
          showToast('Implementation queued. Run implementer.mjs to execute.');
        }).catch(err => {
          showToast('Error: ' + err.message);
        });
      } else {
        closeImplementModal();
        showToast('Firebase offline. Cannot queue implementation.');
      }
    }

    // ========== Progress Bar ==========
    function renderProgress() {
      const section = document.getElementById('progressSection');
      if (!implementStatus || !implementStatus.status || implementStatus.status === 'idle') {
        section.classList.remove('active');
        return;
      }

      section.classList.add('active');
      const { completed = 0, total = 0, currentAction = '', status } = implementStatus;
      const pct = total > 0 ? Math.round((completed / total) * 100) : 0;

      document.getElementById('progressLabel').textContent =
        status === 'done' ? 'Implementation complete!' :
        status === 'error' ? 'Implementation encountered an error' :
        `Implementing changes... (${completed}/${total})`;
      document.getElementById('progressFill').style.width = pct + '%';
      document.getElementById('progressDetail').textContent = currentAction;
    }

    // ========== Alt / Cancel / Filter ==========
    function toggleAlts(id) {
      const el = document.getElementById(id);
      if (el) el.classList.toggle('open');
    }

    function switchAlt(itemId, altName) {
      if (altPreferences[itemId] === altName) {
        delete altPreferences[itemId];
        if (firebaseReady) db.ref('altPreferences').child(String(itemId)).remove();
      } else {
        altPreferences[itemId] = altName;
        if (firebaseReady) db.ref('altPreferences').child(String(itemId)).set(altName);
      }
      localStorage.setItem('sns-alt-prefs', JSON.stringify(altPreferences));
      renderItems(currentFilter());
    }

    function cancelItem(id) {
      const item = items.find(i => i.id === id);
      if (!item) return;
      if (cancelQueue[id]) {
        if (confirm('Undo cancellation for "' + item.name + '"?')) {
          delete cancelQueue[id];
          localStorage.setItem('sns-cancel-queue', JSON.stringify(cancelQueue));
          if (firebaseReady) cancelQueueRef.child(String(id)).remove();
          renderItems(currentFilter());
          showToast('Cancellation undone.');
        }
        return;
      }
      if (!confirm('Cancel subscription for "' + item.name + '"?')) return;
      cancelQueue[id] = { name: item.name, timestamp: Date.now() };
      localStorage.setItem('sns-cancel-queue', JSON.stringify(cancelQueue));
      if (firebaseReady) cancelQueueRef.child(String(id)).set(cancelQueue[id]);
      renderItems(currentFilter());
      showToast('Marked for cancellation.');
    }

    function filterItems(val) {
      renderItems(val);
    }

    function showToast(msg) {
      const t = document.getElementById('toast');
      t.textContent = msg;
      t.classList.add('show');
      setTimeout(() => t.classList.remove('show'), 2500);
    }

    function renderDeletionCandidates() {
      const section = document.getElementById('deletionSection');
      const list = document.getElementById('deletionList');
      const candidates = Object.entries(orderHistory).filter(([id, data]) => data.deletionCandidate);

      if (candidates.length === 0) {
        section.style.display = 'none';
        return;
      }

      section.style.display = 'block';
      list.innerHTML = '';

      for (const [id, data] of candidates) {
        const card = document.createElement('div');
        card.className = 'deletion-card';
        const asin = itemAsins[id];
        const itemObj = items.find(i => i.id === parseInt(id));
        const displayName = data.itemName || (itemObj ? itemObj.name : 'Item ' + id);
        const nameHtml = asin
          ? `<a href="https://www.amazon.com/dp/${asin}" target="_blank" style="color:inherit">${displayName}</a>`
          : displayName;
        card.innerHTML = `
          <div class="dc-name">${nameHtml}</div>
          <div class="dc-reason">${data.deletionReason}</div>
          <div class="dc-stats">
            ${data.orderCount} orders | Avg interval: ${data.avgIntervalDays || '?'} days |
            Last ordered: ${data.lastOrdered} (${data.daysSinceLast}d ago) |
            Total spent: $${data.totalSpent}
          </div>
        `;
        list.appendChild(card);
      }
    }

    // ========== Init ==========
    initFirebase();
    renderAll();
  </script>
</body>
</html>
